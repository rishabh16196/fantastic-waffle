# Leveling Guide Generator - Development Rules

> These rules ensure consistency across the codebase. Follow these patterns when adding new features.

---

## Backend (Python/FastAPI)

### Database Models

1. **Always add audit fields** to new tables:
   ```python
   is_active = Column(Boolean, default=True)
   created_at = Column(DateTime, default=datetime.utcnow)
   updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
   ```

2. **Use soft deletes** - set `is_active=False` instead of deleting rows.

3. **Use UUID strings** for primary keys:
   ```python
   id = Column(String(36), primary_key=True, default=generate_uuid)
   ```

4. **Always scope queries by company_id** for multi-tenant isolation:
   ```python
   db.query(Role).filter(
       Role.company_id == user.company_id,
       Role.is_active == True
   )
   ```

### API Endpoints

1. **Use dependency injection** for auth and database:
   ```python
   def my_endpoint(
       user: User = Depends(require_user),
       db: DBSession = Depends(get_db)
   ):
   ```

2. **Manager-only endpoints** use `require_manager`:
   ```python
   user: User = Depends(require_manager)
   ```

3. **Long-running tasks** must use background processing:
   ```python
   background_tasks.add_task(process_in_background, ...)
   return {"id": resource_id, "status": "processing"}
   ```

4. **Avoid N+1 queries** - fetch related data in bulk:
   ```python
   # BAD: Query per item
   for item in items:
       related = db.query(Related).filter(Related.item_id == item.id).all()
   
   # GOOD: Single query + group in memory
   all_related = db.query(Related).filter(Related.item_id.in_([i.id for i in items])).all()
   related_map = defaultdict(list)
   for r in all_related:
       related_map[r.item_id].append(r)
   ```

### Schemas (Pydantic)

1. **Separate Request and Response schemas**:
   ```python
   class RoleCreateRequest(BaseModel): ...
   class RoleResponse(BaseModel): ...
   ```

2. **Use `from_attributes = True`** for ORM model conversion:
   ```python
   class Config:
       from_attributes = True
   ```

### Prompts & AI

1. **Store prompts in database** - never hardcode in Python.

2. **Default prompts** go in `backend/prompts/defaults.yaml`.

3. **Use Jinja2 templating** with double braces: `{{variable_name}}`.

4. **Parallel API calls** for bulk operations:
   ```python
   with ThreadPoolExecutor(max_workers=BATCH_SIZE) as executor:
       futures = [executor.submit(api_call, item) for item in batch]
       results = [f.result() for f in futures]
   ```

5. **Fetch prompt config once** before parallel execution, pass to workers.

### Error Handling

1. **Use HTTPException** with appropriate status codes:
   ```python
   raise HTTPException(status_code=404, detail="Resource not found")
   raise HTTPException(status_code=403, detail="Access denied")
   raise HTTPException(status_code=400, detail="Invalid request")
   ```

---

## Frontend (React/TypeScript)

### Components

1. **Use functional components** with hooks, not class components.

2. **TypeScript interfaces** for all props and API responses:
   ```typescript
   interface RoleResponse {
     id: string;
     name: string;
     // ...
   }
   ```

3. **CSS modules** or separate `.css` files per component.

### API Calls

1. **Centralize API calls** in `src/api.ts`:
   ```typescript
   export const fetchRoles = async (): Promise<RoleResponse[]> => {
     const response = await fetch(`${API_URL}/roles`, { headers });
     return response.json();
   };
   ```

2. **Always include auth header**:
   ```typescript
   headers: { 'X-User-Email': userEmail }
   ```

### State Management

1. **Use React Context** for global state (auth, user info).

2. **useState/useEffect** for component-local state.

3. **Avoid prop drilling** - use context or composition.

### UI Patterns

1. **Leveling guide grid**: Levels as columns, competencies as rows.

2. **Modals for details** instead of inline expansion.

3. **Confirmation dialogs** before destructive actions (overwrite, delete).

4. **Loading states** with spinners during async operations.

5. **Poll for status** on long-running operations:
   ```typescript
   const pollStatus = async (roleId: string) => {
     const status = await checkRoleStatus(roleId);
     if (status.status === 'processing') {
       setTimeout(() => pollStatus(roleId), 2000);
     }
   };
   ```

---

## Database

### Development
- Use **SQLite** with `DATABASE_URL=sqlite:///./leveling_guide.db`
- WAL mode is auto-enabled for concurrency

### Production
- Use **PostgreSQL** via Neon or similar managed service
- Connection string in `DATABASE_URL` secret

### Migrations
- SQLAlchemy `create_all()` on startup creates missing tables
- For schema changes, manually update models and recreate DB (or add Alembic later)

---

## Docker & Deployment

### Local Development
```bash
docker compose up              # Build and run
docker compose --profile dev up  # With hot-reload frontend
docker compose build --no-cache  # Rebuild after requirements.txt changes
```

### Production Deployment
- Push to `main` branch triggers GitHub Actions
- Images pushed to GitHub Container Registry (GHCR)
- Deploy via SSH to DigitalOcean droplet
- Use `docker compose` (V2, with space) not `docker-compose`

### Environment Variables
All secrets in GitHub Actions:
- `DATABASE_URL`
- `OPENAI_API_KEY`
- `SSH_HOST`, `SSH_USERNAME`, `SSH_PRIVATE_KEY`
- `GHCR_TOKEN`

---

## File Structure

```
backend/
├── main.py           # FastAPI app, endpoints
├── models.py         # SQLAlchemy ORM models
├── schemas.py        # Pydantic request/response schemas
├── database.py       # DB connection, session
├── auth.py           # Authentication helpers
├── openai_service.py # AI/LLM integration
├── prompt_service.py # Prompt management
├── file_parser.py    # PDF/text extraction
├── prompts/
│   ├── __init__.py
│   └── defaults.yaml # Default prompt templates
└── requirements.txt

frontend/
├── src/
│   ├── api.ts        # API client functions
│   ├── App.tsx       # Main app component
│   ├── components/   # React components
│   └── context/      # React contexts (auth, etc.)
├── index.html
└── vite.config.ts

docs/
└── ARCHITECTURE_DECISIONS.md  # Design decisions & tradeoffs
```

---

## Git Workflow

1. **Feature branches** off `main`
2. **PR reviews** before merge
3. **Push to main** triggers production deploy
4. **Push to staging** triggers staging deploy (if configured)

---

## Testing (Future)

- Backend: pytest with FastAPI TestClient
- Frontend: Vitest + React Testing Library
- CI runs tests before deploy (currently commented out)
